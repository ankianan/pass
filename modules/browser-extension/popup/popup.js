(()=>{"use strict";const e=new TextEncoder,t=new TextDecoder,r=2**32;function n(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let n=0;return e.forEach((e=>{r.set(e,n),n+=e.length})),r}function a(e,t,n){if(t<0||t>=r)throw new RangeError(`value must be >= 0 and <= 4294967295. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],n)}function i(e){const t=Math.floor(e/r),n=e%r,i=new Uint8Array(8);return a(i,t,0),a(i,n,4),i}function o(e){const t=new Uint8Array(4);return a(t,e),t}function s(e){return n(o(e.length),e)}const c=t=>(t=>{let r=t;"string"==typeof r&&(r=e.encode(r));const n=[];for(let e=0;e<r.length;e+=32768)n.push(String.fromCharCode.apply(null,r.subarray(e,e+32768)));return btoa(n.join(""))})(t).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),d=e=>{let r=e;r instanceof Uint8Array&&(r=t.decode(r)),r=r.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>new Uint8Array(atob(e).split("").map((e=>e.charCodeAt(0)))))(r)}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}};class p extends Error{constructor(e){var t;super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,null===(t=Error.captureStackTrace)||void 0===t||t.call(Error,this,this.constructor)}static get code(){return"ERR_JOSE_GENERIC"}}class u extends p{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class y extends p{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class l extends p{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class h extends p{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}const w=crypto;function E(e){try{return null!=e&&"boolean"==typeof e.extractable&&"string"==typeof e.algorithm.name&&"string"==typeof e.type}catch(e){return!1}}const f=w.getRandomValues.bind(w);function A(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new y(`Unsupported JWE Algorithm: ${e}`)}}const m=e=>f(new Uint8Array(A(e)>>3)),g=(e,t)=>{if(t.length<<3!==A(e))throw new h("Invalid Initialization Vector length")},v=(e,t)=>{if(e.length<<3!==t)throw new h("Invalid Content Encryption Key length")};function S(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function b(e,t){return e.name===t}function C(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!b(e.algorithm,"AES-GCM"))throw S("AES-GCM");const r=parseInt(t.substr(1,3),10);if(e.algorithm.length!==r)throw S(r,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!b(e.algorithm,"AES-KW"))throw S("AES-KW");const r=parseInt(t.substr(1,3),10);if(e.algorithm.length!==r)throw S(r,"algorithm.length");break}case"ECDH-ES":if(!b(e.algorithm,"ECDH"))throw S("ECDH");break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!b(e.algorithm,"PBKDF2"))throw S("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!b(e.algorithm,"RSA-OAEP"))throw S("RSA-OAEP");const r=parseInt(t.substr(9),10)||1;if(n=e.algorithm.hash,parseInt(n.name.substr(4),10)!==r)throw S(`SHA-${r}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}var n;!function(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}(e,r)}const H=(e,...t)=>{let r="Key must be ";if(t.length>2){const e=t.pop();r+=`one of type ${t.join(", ")}, or ${e}.`}else 2===t.length?r+=`one of type ${t[0]} or ${t[1]}.`:r+=`of type ${t[0]}.`;return null==e?r+=` Received ${e}`:"function"==typeof e&&e.name?r+=` Received function ${e.name}`:"object"==typeof e&&null!=e&&e.constructor&&e.constructor.name&&(r+=` Received an instance of ${e.constructor.name}`),r},K=e=>E(e),P=["CryptoKey"],W=async(e,t,r,a,o,s)=>{if(!(E(t)||t instanceof Uint8Array))throw new TypeError(H(t,...P,"Uint8Array"));switch(g(e,a),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&v(t,parseInt(e.substr(-3),10)),async function(e,t,r,a,o,s){if(!(t instanceof Uint8Array))throw new TypeError(H(t,"Uint8Array"));const c=parseInt(e.substr(1,3),10),d=await w.subtle.importKey("raw",t.subarray(c>>3),"AES-CBC",!1,["decrypt"]),p=await w.subtle.importKey("raw",t.subarray(0,c>>3),{hash:"SHA-"+(c<<1),name:"HMAC"},!1,["sign"]),u=n(s,a,r,i(s.length<<3)),y=new Uint8Array((await w.subtle.sign("HMAC",p,u)).slice(0,c>>3));let h,E;try{h=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const r=e.length;let n=0,a=-1;for(;++a<r;)n|=e[a]^t[a];return 0===n})(o,y)}catch(e){}if(!h)throw new l;try{E=new Uint8Array(await w.subtle.decrypt({iv:a,name:"AES-CBC"},d,r))}catch(e){}if(!E)throw new l;return E}(e,t,r,a,o,s);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&v(t,parseInt(e.substr(1,3),10)),async function(e,t,r,a,i,o){let s;t instanceof Uint8Array?s=await w.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(C(t,e,"decrypt"),s=t);try{return new Uint8Array(await w.subtle.decrypt({additionalData:o,iv:a,name:"AES-GCM",tagLength:128},s,n(r,i)))}catch(e){throw new l}}(e,t,r,a,o,s);default:throw new y("Unsupported JWE Content Encryption Algorithm")}},k=async()=>{throw new y('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.')},_=async()=>{throw new y('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.')},U=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0};function D(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}const R=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];function O(e,t){if(e.algorithm.length!==parseInt(t.substr(1,3),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function J(e,t,r){if(E(e))return C(e,t,r),e;if(e instanceof Uint8Array)return w.subtle.importKey("raw",e,"AES-KW",!0,[r]);throw new TypeError(H(e,...P,"Uint8Array"))}const T=async(e,t,r)=>{const n=await J(t,e,"wrapKey");O(n,e);const a=await w.subtle.importKey("raw",r,...R);return new Uint8Array(await w.subtle.wrapKey("raw",a,n,"AES-KW"))},B=async(e,t,r)=>{const n=await J(t,e,"unwrapKey");O(n,e);const a=await w.subtle.unwrapKey("raw",r,n,"AES-KW",...R);return new Uint8Array(await w.subtle.exportKey("raw",a))},M=async(e,t)=>{const r=`SHA-${e.substr(-3)}`;return new Uint8Array(await w.subtle.digest(r,t))},I=async(t,r,a,i,c=new Uint8Array(0),d=new Uint8Array(0))=>{if(!E(t))throw new TypeError(H(t,...P));if(C(t,"ECDH-ES"),!E(r))throw new TypeError(H(r,...P));C(r,"ECDH-ES","deriveBits","deriveKey");const p=n(s(e.encode(a)),s(c),s(d),o(i));if(!r.usages.includes("deriveBits"))throw new TypeError('ECDH-ES private key "usages" must include "deriveBits"');const u=new Uint8Array(await w.subtle.deriveBits({name:"ECDH",public:t},r,Math.ceil(parseInt(r.algorithm.namedCurve.substr(-3),10)/8)<<3));return async function(e,t,r,a){const i=Math.ceil((r>>3)/32);let s;for(let r=1;r<=i;r++){const i=new Uint8Array(4+t.length+a.length);i.set(o(r)),i.set(t,4),i.set(a,4+t.length),s=s?n(s,await e("sha256",i)):await e("sha256",i)}return s=s.slice(0,r>>3),s}(M,u,i,p)},x=e=>{if(!E(e))throw new TypeError(H(e,...P));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)};async function G(t,r,a,i){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new h("PBES2 Salt Input must be 8 or more octets")}(t);const o=function(t,r){return n(e.encode(t),new Uint8Array([0]),r)}(r,t),s=parseInt(r.substr(13,3),10),c={hash:`SHA-${r.substr(8,3)}`,iterations:a,name:"PBKDF2",salt:o},d={length:s,name:"AES-KW"},p=await function(e,t){if(e instanceof Uint8Array)return w.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(E(e))return C(e,t,"deriveBits","deriveKey"),e;throw new TypeError(H(e,...P,"Uint8Array"))}(i,r);if(p.usages.includes("deriveBits"))return new Uint8Array(await w.subtle.deriveBits(c,p,s));if(p.usages.includes("deriveKey"))return w.subtle.deriveKey(c,p,d,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}function $(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new y(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}const j=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function L(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new y(`Unsupported JWE Algorithm: ${e}`)}}const z=e=>f(new Uint8Array(L(e)>>3));function N(){return"function"==typeof WebSocketPair}function F(){try{return void 0!==process.versions.node}catch(e){return!1}}const V=async e=>{var t,r;const{algorithm:n,keyUsages:a}=function(e){let t,r;switch(e.kty){case"oct":switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:`SHA-${e.alg.substr(-3)}`},r=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new y(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"},r=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"},r=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"},r=["deriveBits"];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.substr(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.substr(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.substr(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case(N()||F())&&"OKP":if("EdDSA"!==e.alg)throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');switch(e.crv){case"Ed25519":t={name:"NODE-ED25519",namedCurve:"NODE-ED25519"},r=e.d?["sign"]:["verify"];break;case F()&&"Ed448":t={name:"NODE-ED448",namedCurve:"NODE-ED448"},r=e.d?["sign"]:["verify"];break;default:throw new y('Invalid or unsupported JWK "crv" (Subtype of Key Pair) Parameter value')}break;default:throw new y('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(e),i=[n,null!==(t=e.ext)&&void 0!==t&&t,null!==(r=e.key_ops)&&void 0!==r?r:a];if("PBKDF2"===n.name)return w.subtle.importKey("raw",d(e.k),...i);const o={...e};return delete o.alg,w.subtle.importKey("jwk",o,...i)};async function Y(e,t,r){if(!D(e))throw new TypeError("JWK must be an object");if(t||(t=e.alg),"string"!=typeof t||!t)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');switch(e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return null!=r||(r=!0!==e.ext),r?V({...e,alg:t,ext:!1}):d(e.k);case"RSA":if(void 0!==e.oth)throw new y('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return V({...e,alg:t});default:throw new y('Unsupported "kty" (Key Type) Parameter value')}}const q=(e,t,r)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?(e=>{if(!(e instanceof Uint8Array)){if(!K(e))throw new TypeError(H(e,...P,"Uint8Array"));if("secret"!==e.type)throw new TypeError(`${P.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(t):((e,t)=>{if(!K(e))throw new TypeError(H(e,...P));if("secret"===e.type)throw new TypeError(`${P.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===t&&"public"===e.type)throw new TypeError(`${P.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===t&&"public"===e.type)throw new TypeError(`${P.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(e.algorithm&&"verify"===t&&"private"===e.type)throw new TypeError(`${P.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(e.algorithm&&"encrypt"===t&&"private"===e.type)throw new TypeError(`${P.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(t,r)},Q=async(e,t,r,a,o)=>{if(!(E(r)||r instanceof Uint8Array))throw new TypeError(H(r,...P,"Uint8Array"));switch(g(e,a),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return r instanceof Uint8Array&&v(r,parseInt(e.substr(-3),10)),async function(e,t,r,a,o){if(!(r instanceof Uint8Array))throw new TypeError(H(r,"Uint8Array"));const s=parseInt(e.substr(1,3),10),c=await w.subtle.importKey("raw",r.subarray(s>>3),"AES-CBC",!1,["encrypt"]),d=await w.subtle.importKey("raw",r.subarray(0,s>>3),{hash:"SHA-"+(s<<1),name:"HMAC"},!1,["sign"]),p=new Uint8Array(await w.subtle.encrypt({iv:a,name:"AES-CBC"},c,t)),u=n(o,a,p,i(o.length<<3));return{ciphertext:p,tag:new Uint8Array((await w.subtle.sign("HMAC",d,u)).slice(0,s>>3))}}(e,t,r,a,o);case"A128GCM":case"A192GCM":case"A256GCM":return r instanceof Uint8Array&&v(r,parseInt(e.substr(1,3),10)),async function(e,t,r,n,a){let i;r instanceof Uint8Array?i=await w.subtle.importKey("raw",r,"AES-GCM",!1,["encrypt"]):(C(r,e,"encrypt"),i=r);const o=new Uint8Array(await w.subtle.encrypt({additionalData:a,iv:n,name:"AES-GCM",tagLength:128},i,t)),s=o.slice(-16);return{ciphertext:o.slice(0,-16),tag:s}}(e,t,r,a,o);default:throw new y("Unsupported JWE Content Encryption Algorithm")}},X=function(e,t,r,n,a){if(void 0!==a.crit&&void 0===n.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||void 0===n.crit)return new Set;if(!Array.isArray(n.crit)||0===n.crit.length||n.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let i;i=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of n.crit){if(!i.has(t))throw new y(`Extension Header Parameter "${t}" is not recognized`);if(void 0===a[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(i.get(t)&&void 0===n[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(n.crit)},Z=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function ee(r,a,i){var o;if(!D(r))throw new h("Flattened JWE must be an object");if(void 0===r.protected&&void 0===r.header&&void 0===r.unprotected)throw new h("JOSE Header missing");if("string"!=typeof r.iv)throw new h("JWE Initialization Vector missing or incorrect type");if("string"!=typeof r.ciphertext)throw new h("JWE Ciphertext missing or incorrect type");if("string"!=typeof r.tag)throw new h("JWE Authentication Tag missing or incorrect type");if(void 0!==r.protected&&"string"!=typeof r.protected)throw new h("JWE Protected Header incorrect type");if(void 0!==r.encrypted_key&&"string"!=typeof r.encrypted_key)throw new h("JWE Encrypted Key incorrect type");if(void 0!==r.aad&&"string"!=typeof r.aad)throw new h("JWE AAD incorrect type");if(void 0!==r.header&&!D(r.header))throw new h("JWE Shared Unprotected Header incorrect type");if(void 0!==r.unprotected&&!D(r.unprotected))throw new h("JWE Per-Recipient Unprotected Header incorrect type");let s;if(r.protected){const e=d(r.protected);try{s=JSON.parse(t.decode(e))}catch(e){throw new h("JWE Protected Header is invalid")}}if(!U(s,r.header,r.unprotected))throw new h("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const c={...s,...r.header,...r.unprotected};if(X(h,new Map,null==i?void 0:i.crit,s,c),void 0!==c.zip){if(!s||!s.zip)throw new h('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==c.zip)throw new y('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:p,enc:l}=c;if("string"!=typeof p||!p)throw new h("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof l||!l)throw new h("missing JWE Encryption Algorithm (enc) in JWE Header");const f=i&&Z("keyManagementAlgorithms",i.keyManagementAlgorithms),A=i&&Z("contentEncryptionAlgorithms",i.contentEncryptionAlgorithms);if(f&&!f.has(p))throw new u('"alg" (Algorithm) Header Parameter not allowed');if(A&&!A.has(l))throw new u('"enc" (Encryption Algorithm) Header Parameter not allowed');let m;void 0!==r.encrypted_key&&(m=d(r.encrypted_key));let g,v=!1;"function"==typeof a&&(a=await a(s,r),v=!0);try{g=await async function(e,t,r,n){switch(q(e,t,"decrypt"),e){case"dir":if(void 0!==r)throw new h("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==r)throw new h("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!D(n.epk))throw new h('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!x(t))throw new y("ECDH-ES with the provided key is not allowed or not supported by your javascript runtime");const a=await Y(n.epk,e);let i,o;if(void 0!==n.apu){if("string"!=typeof n.apu)throw new h('JOSE Header "apu" (Agreement PartyUInfo) invalid');i=d(n.apu)}if(void 0!==n.apv){if("string"!=typeof n.apv)throw new h('JOSE Header "apv" (Agreement PartyVInfo) invalid');o=d(n.apv)}const s=await I(a,t,"ECDH-ES"===e?n.enc:e,"ECDH-ES"===e?L(n.enc):parseInt(e.substr(-5,3),10),i,o);if("ECDH-ES"===e)return s;if(void 0===r)throw new h("JWE Encrypted Key missing");return B(e.substr(-6),s,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===r)throw new h("JWE Encrypted Key missing");return(async(e,t,r)=>{if(!E(t))throw new TypeError(H(t,...P));if(C(t,e,"decrypt","unwrapKey"),j(e,t),t.usages.includes("decrypt"))return new Uint8Array(await w.subtle.decrypt($(e),t,r));if(t.usages.includes("unwrapKey")){const n=await w.subtle.unwrapKey("raw",r,t,$(e),...R);return new Uint8Array(await w.subtle.exportKey("raw",n))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')})(e,t,r);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(void 0===r)throw new h("JWE Encrypted Key missing");if("number"!=typeof n.p2c)throw new h('JOSE Header "p2c" (PBES2 Count) missing or invalid');if("string"!=typeof n.p2s)throw new h('JOSE Header "p2s" (PBES2 Salt) missing or invalid');return(async(e,t,r,n,a)=>{const i=await G(a,e,n,t);return B(e.substr(-6),i,r)})(e,t,r,n.p2c,d(n.p2s));case"A128KW":case"A192KW":case"A256KW":if(void 0===r)throw new h("JWE Encrypted Key missing");return B(e,t,r);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":if(void 0===r)throw new h("JWE Encrypted Key missing");if("string"!=typeof n.iv)throw new h('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof n.tag)throw new h('JOSE Header "tag" (Authentication Tag) missing or invalid');return async function(e,t,r,n,a){const i=e.substr(0,7);return W(i,t,r,n,a,new Uint8Array(0))}(e,t,r,d(n.iv),d(n.tag));default:throw new y('Invalid or unsupported "alg" (JWE Algorithm) header value')}}(p,a,m,c)}catch(e){if(e instanceof TypeError)throw e;g=z(l)}const S=d(r.iv),b=d(r.tag),K=e.encode(null!==(o=r.protected)&&void 0!==o?o:"");let _;_=void 0!==r.aad?n(K,e.encode("."),e.encode(r.aad)):K;let O=await W(l,g,d(r.ciphertext),S,b,_);"DEF"===c.zip&&(O=await((null==i?void 0:i.inflateRaw)||k)(O));const J={plaintext:O};return void 0!==r.protected&&(J.protectedHeader=s),void 0!==r.aad&&(J.additionalAuthenticatedData=d(r.aad)),void 0!==r.unprotected&&(J.sharedUnprotectedHeader=r.unprotected),void 0!==r.header&&(J.unprotectedHeader=r.header),v?{...J,key:a}:J}async function te(e){return(async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:c(e)};if(!E(e))throw new TypeError(H(e,...P,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:t,key_ops:r,alg:n,use:a,...i}=await w.subtle.exportKey("jwk",e);return i})(e)}const re=Symbol();class ne{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(r,a){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new h("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!U(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new h("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const i={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(X(h,new Map,null==a?void 0:a.crit,this._protectedHeader,i),void 0!==i.zip){if(!this._protectedHeader||!this._protectedHeader.zip)throw new h('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==i.zip)throw new y('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:o,enc:s}=i;if("string"!=typeof o||!o)throw new h('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof s||!s)throw new h('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let d,p,u,l,A,g,v;if("dir"===o){if(this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption")}else if("ECDH-ES"===o&&this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");{let e;({cek:p,encryptedKey:d,parameters:e}=await async function(e,t,r,n,a={}){let i,o,s;switch(q(e,r,"encrypt"),e){case"dir":s=r;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!x(r))throw new y("ECDH-ES with the provided key is not allowed or not supported by your javascript runtime");const{apu:d,apv:p}=a;let{epk:u}=a;u||(u=await(async e=>{if(!E(e))throw new TypeError(H(e,...P));return(await w.subtle.generateKey({name:"ECDH",namedCurve:e.algorithm.namedCurve},!0,["deriveBits"])).privateKey})(r));const{x:l,y:h,crv:f,kty:A}=await te(u),m=await I(r,u,"ECDH-ES"===e?t:e,"ECDH-ES"===e?L(t):parseInt(e.substr(-5,3),10),d,p);if(o={epk:{x:l,y:h,crv:f,kty:A}},d&&(o.apu=c(d)),p&&(o.apv=c(p)),"ECDH-ES"===e){s=m;break}s=n||z(t);const g=e.substr(-6);i=await T(g,m,s);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":s=n||z(t),i=await(async(e,t,r)=>{if(!E(t))throw new TypeError(H(t,...P));if(C(t,e,"encrypt","wrapKey"),j(e,t),t.usages.includes("encrypt"))return new Uint8Array(await w.subtle.encrypt($(e),t,r));if(t.usages.includes("wrapKey")){const n=await w.subtle.importKey("raw",r,...R);return new Uint8Array(await w.subtle.wrapKey("raw",n,t,$(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(e,r,s);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{s=n||z(t);const{p2c:d,p2s:p}=a;({encryptedKey:i,...o}=await(async(e,t,r,n=Math.floor(2049*Math.random())+2048,a=f(new Uint8Array(16)))=>{const i=await G(a,e,n,t);return{encryptedKey:await T(e.substr(-6),i,r),p2c:n,p2s:c(a)}})(e,r,s,d,p));break}case"A128KW":case"A192KW":case"A256KW":s=n||z(t),i=await T(e,r,s);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{s=n||z(t);const{iv:d}=a;({encryptedKey:i,...o}=await async function(e,t,r,n){const a=e.substr(0,7);n||(n=m(a));const{ciphertext:i,tag:o}=await Q(a,r,t,n,new Uint8Array(0));return{encryptedKey:i,iv:c(n),tag:c(o)}}(e,r,s,d));break}default:throw new y('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:s,encryptedKey:i,parameters:o}}(o,s,r,this._cek,this._keyManagementParameters)),e&&(a&&re in a?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...e}:this.setUnprotectedHeader(e):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...e}:this.setProtectedHeader(e))}if(this._iv||(this._iv=m(s)),l=this._protectedHeader?e.encode(c(JSON.stringify(this._protectedHeader))):e.encode(""),this._aad?(A=c(this._aad),u=n(l,e.encode("."),e.encode(A))):u=l,"DEF"===i.zip){const e=await((null==a?void 0:a.deflateRaw)||_)(this._plaintext);({ciphertext:g,tag:v}=await Q(s,e,p,this._iv,u))}else({ciphertext:g,tag:v}=await Q(s,this._plaintext,p,this._iv,u));const S={ciphertext:c(g),iv:c(this._iv),tag:c(v)};return d&&(S.encrypted_key=c(d)),A&&(S.aad=A),this._protectedHeader&&(S.protected=t.decode(l)),this._sharedUnprotectedHeader&&(S.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(S.header=this._unprotectedHeader),S}}class ae{constructor(e){this._flattened=new ne(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){const r=await this._flattened.encrypt(e,t);return[r.protected,r.encrypted_key,r.iv,r.ciphertext,r.tag].join(".")}}function ie(e){var t;const r=null!==(t=null==e?void 0:e.modulusLength)&&void 0!==t?t:2048;if("number"!=typeof r||r<2048)throw new y("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return r}const oe="RSA-OAEP-256";class se{constructor(e,t){this.did=e,this.privateKey=t}static async create(){const{publicKey:e,privateKey:t}=await async function(e,t){return async function(e,t){var r,n;let a,i;switch(e){case"PS256":case"PS384":case"PS512":a={name:"RSA-PSS",hash:`SHA-${e.substr(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:ie(t)},i=["sign","verify"];break;case"RS256":case"RS384":case"RS512":a={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.substr(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:ie(t)},i=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":a={name:"RSA-OAEP",hash:`SHA-${parseInt(e.substr(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:ie(t)},i=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":a={name:"ECDSA",namedCurve:"P-256"},i=["sign","verify"];break;case"ES384":a={name:"ECDSA",namedCurve:"P-384"},i=["sign","verify"];break;case"ES512":a={name:"ECDSA",namedCurve:"P-521"},i=["sign","verify"];break;case(N()||F())&&"EdDSA":switch(null==t?void 0:t.crv){case void 0:case"Ed25519":a={name:"NODE-ED25519",namedCurve:"NODE-ED25519"},i=["sign","verify"];break;case F()&&"Ed448":a={name:"NODE-ED448",namedCurve:"NODE-ED448"},i=["sign","verify"];break;default:throw new y("Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448")}break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":a={name:"ECDH",namedCurve:null!==(r=null==t?void 0:t.crv)&&void 0!==r?r:"P-256"},i=["deriveKey","deriveBits"];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return w.subtle.generateKey(a,null!==(n=null==t?void 0:t.extractable)&&void 0!==n&&n,i)}(e,t)}(oe),r=await te(e);let n=new ION.DID({content:{publicKeys:[{id:"key-1",type:"JsonWebKey",publicKeyJwk:r,purposes:["authentication"]}],services:[{id:"domain-1",type:"LinkedDomains",serviceEndpoint:"https://foo.example.com"}]}});return new se(await n.getURI(),t)}}let ce=null;document.getElementById("encryptButton").addEventListener("click",(async function(e){const t=document.getElementById("encryption-form"),r=t.elements.did,n=t.elements.input;n.value=await async function(e,t){const r=await async function(e){return await ION.resolve(e)}(t),n=await Y(r.didDocument.verificationMethod[0].publicKeyJwk,oe),a=await async function(e,t){return await new ae((new TextEncoder).encode(t)).setProtectedHeader({alg:oe,enc:"A256GCM"}).encrypt(e)}(n,e);return a}(n.value,r.value)})),document.getElementById("createButton").addEventListener("click",(async function(e){ce||(ce=await se.create(),document.getElementById("create-account-form").elements.did.value=ce.did)})),document.getElementById("decryptButton").addEventListener("click",(async function(e){const r=document.getElementById("decryption-form").elements.input;r.value=await async function(e,r){const{plaintext:n}=await async function(e,r,n){if(e instanceof Uint8Array&&(e=t.decode(e)),"string"!=typeof e)throw new h("Compact JWE must be a string or Uint8Array");const{0:a,1:i,2:o,3:s,4:c,length:d}=e.split(".");if(5!==d)throw new h("Invalid Compact JWE");const p=await ee({ciphertext:s||void 0,iv:o||void 0,protected:a||void 0,tag:c||void 0,encrypted_key:i||void 0},r,void 0),u={plaintext:p.plaintext,protectedHeader:p.protectedHeader};return"function"==typeof r?{...u,key:p.key}:u}(e,r);return(new TextDecoder).decode(n)}(r.value,ce.privateKey)})),document.getElementsByName("opt").forEach(function(){let e=null;return function(t){t.hasAttribute("checked")&&(e=document.getElementById(""+t.dataset.for),e.classList.add("show")),t.addEventListener("change",(function(t){e?.classList.remove("show");const r=document.getElementById(""+t.target.dataset.for);r.classList.add("show"),e=r}))}}())})();